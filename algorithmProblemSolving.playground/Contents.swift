import Foundation

print("_____1_____")
// Problem Archives -> https: //projecteuler.net/archives

// 1 - If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3,5,6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.

var sum: Int = 0

@MainActor
func sumMultiplesOfThreeOrFive(ofLimit limit: Int) -> Int {
    
    for number in 1..<limit {
        if number % 3 == 0 || number % 5 == 0 {
            sum += number
        }
    }
    
    return sum
}

let multipleTen = sumMultiplesOfThreeOrFive(ofLimit: 10)
print("A soma total dos números múltiplos de 5 ou 3, abaixo de 1000 é igual a \(multipleTen)\n ")

var number: Int = 0
for numCode in 1..<10 {
     
    if (numCode % 3 == 0) || (numCode % 5 == 0){
        
        number += numCode
        //print(numCode)
    }
}
print("A soma total dos números abaixo de 10 é igual a \(number).")

number = 0
for numMil in 1..<1000 {
    
    if (numMil % 3 == 0) || (numMil % 5 == 0){
       
        number += numMil
        //print(numMil)
    }
}
print("A soma total dos números abaixo de 1000 é igua a \(number).")

func sumMultiples(ofLimit limit: Int) -> Int {
    
   var sum: Int = 0
    
    for number in 1..<limit {
        if number % 3 == 0 || number % 5 == 0 {
            sum += number
        }
    }
    
    return sum
}

let result1 = sumMultiples(ofLimit: 10)
print("A função soma total dos números abaixo de 10 é igual a \(result1).")
let result2 = sumMultiples(ofLimit: 1000)
print("A função soma total dos números abaixo de 1000 é igual a \(result2).")
let result3 = sumMultiples(ofLimit: 3000)
print("A função soma total dos números abaixo de 3000 é igual a \(result3).")

print("_____2_____")
// 2 - Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1,2,3,5,8,13,21,34,55,89,... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

func fibonacci(ofLimit limit: Int) -> Int {
    var number1: Int = 1
    var number2: Int = 2
    var sum: Int = 0
    
    while number2 <= limit {
        
        if number2 % 2 == 0 {
            sum += number2
        }
        let temp = number1 + number2
        number1 = number2
        number2 = temp
    }
    return sum
}

print("A soma total dos números pares da sequência de Fibonacci até 4.000.000 é igual a \(fibonacci(ofLimit: 4_000_000)).")

// Função para gerar e imprimir a sequência de Fibonacci até um limite
func generateFibonacci(upTo limit: Int) -> [Int] {
    var number1 = 1
    var number2 = 2
    var fibonacciSequence: [Int] = [number1, number2]

    while true {
        let nextNumber = number1 + number2
        if nextNumber > limit {
            break
        }
        fibonacciSequence.append(nextNumber)
        number1 = number2
        number2 = nextNumber
    }

    // Imprimir a sequência completa
    print("Sequência de Fibonacci até \(limit):")
    for number in fibonacciSequence {
        if number % 2 == 0 {
            print("\(number) (par)")
        } else {
            print(number)
        }
    }

    return fibonacciSequence
}
let evenSumOdd = generateFibonacci(upTo: 10)
print("Sequência de Fibonacci até 10, é igual a \(evenSumOdd).")

// Função para somar apenas os números pares da sequência
func sumEvenFibonacciNumbersPair(from sequence: [Int]) -> Int {
    let evenNumbers = sequence.filter { $0 % 2 == 0 }
    return evenNumbers.reduce(0, +)
}

// Função para somar apenas os números ímpares da sequência
func sumEvenFibonacciNumbersOdd(from sequence: [Int]) -> Int {
    let evenNumbers = sequence.filter { $0 % 2 != 0 }
    return evenNumbers.reduce(0, +)
}


// Uso
let fibonacciSeq = generateFibonacci(upTo: 4_000_000)
let evenSumPair = sumEvenFibonacciNumbersPair(from: fibonacciSeq)
print("A soma total dos números pares da sequência de Fibonacci até 4_000_000 é igual a \(evenSumPair).")

let evenSum = sumEvenFibonacciNumbersOdd(from: fibonacciSeq)
print("A soma total dos números ímpares da sequência de Fibonacci até 4_000_000 é igual a \(evenSum).")
print("--------3---------")
print("--- 3 problema - Os fatores primos de 13195 são 5, 7, 13, 29. Qual é o maior fator primo do número 600851475143 ? ---")
          
func isPrime(ofNumber number: Int) -> Bool {
    if number <= 1 { return false }
    if number == 2 { return true }
    
    //sqrt()é uma função da biblioteca padrão: -> "square root" → raiz quadrada.
    //(sqrt (Double (number))) ->  converte Int para Double
    for i in 2...Int(sqrt (Double (number))) {
        if number % i == 0 {
            return false
        } else {
        }
    }
    return true
}

let isNumberPrimo1 = isPrime(ofNumber: 600851475143)
print(" O número 600851475143 é primo ? \(isNumberPrimo1)")
let isNumberPrimo2 = isPrime(ofNumber: 600851475143)
print(" O número 600851475143 é primo ? \(isNumberPrimo2)")
let isNumberPrimo3 = isPrime(ofNumber: 7)
print(" O número 7 é primo ? \(isNumberPrimo3)")

func isNumPrime(ofNumber number: Int) -> Bool {
    if number <= 1 { return false }
    if number == 2 {
        print("\(number) - É primo.")
        return true
    }

    for i in 2...Int(sqrt(Double(number))) {
        if number % i == 0 {
            print("\(number) - Não é primo (divisível por \(i)).")
            return false
        }
    }

    print("\(number) - É primo.")
    return true
}

let isNumberPrimo5 = isNumPrime(ofNumber: 600851475143)
print("O número 600851475143 é primo? \(isNumberPrimo5)")

let isNumberPrimo6 = isNumPrime(ofNumber: 600851475143)
print("O número 600851475143 é primo? \(isNumberPrimo6)")

let isNumberPrimo7 = isNumPrime(ofNumber: 7)
print("O número 7 é primo? \(isNumberPrimo7)")

/*
 Crivo de Eratóstenes
 Lógica:
 
 1- Comece com uma lista de números de 2 até um limite.

 2- Elimine os múltiplos de 2 (exceto o próprio 2).

 3- Vá para o próximo número não excluído e elimine seus múltiplos.

 4- Continue até o final.

 5- Os que sobrarem são primos.
 */

func sieveOfEratosthenes(limit: Int) -> [Int] {
    var isPrime = [Bool](repeating: true, count: limit + 1)
    isPrime[0] = false
    isPrime[1] = false

    for i in 2...Int(sqrt(Double(limit))) {
        if isPrime[i] {
            for multiple in stride(from: i * i, through: limit, by: i) {
                isPrime[multiple] = false
            }
        }
    }

    return (2...limit).filter { isPrime[$0] }
}

let primesUpTo100 = sieveOfEratosthenes(limit: 100)
print(primesUpTo100)

func generatePrimes(ofLimit limit: Int) -> [Int] {
    var primes: [Int] = []

    for number in 2...limit {
        var isPrime = true
        
        if number > 3 {
            // Testa divisores de 2 até number / 2
            for divisor in 2...(number / 2) {
                if number % divisor == 0 {
                    isPrime = false
                    break
                }
            }
        }

        if isPrime {
            primes.append(number)
        }
    }

    return primes
}

let primesUpTo = generatePrimes(ofLimit: 50)
print("Primos até 50:", primesUpTo)

// função para fatorar com num primos:
func primeFactors(of number: Int) -> [Int] {
    var n = number
    var factors: [Int] = []
    var divisor = 2

    while n > 1 {
        if n % divisor == 0 {
            factors.append(divisor)
            n /= divisor
        } else {
            divisor += 1
        }
    }

    return factors
}

let fatores = primeFactors(of: 13195)
print("Fatores primos de 13195 são:", fatores)

let respostaProblema3 = primeFactors(of: 600851475143)
print("A resposta do Problema 3 -> Os fatores primos de 600851475143 são:", respostaProblema3)

