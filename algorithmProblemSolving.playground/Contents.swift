import Foundation

//Problem Archives -> https: //projecteuler.net/archives

print(" problema 1 - If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3,5,6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.")
var soma: Int = 0

@MainActor
func somaMultiplosDeTresOuCinco(ateLimite limite: Int) -> Int {
    for numero in 1..<limite {
        if numero % 3 ==0 || numero % 5 == 0 {
            soma += numero
        }
    }
}

let multiploDe10: Int = somaMultiplosDeTresOuCinco(ateLimite: 10)
print("A soma total dos n√∫meros m√∫ltiplos de 5 ou 3, abaixo de 1000 √© igual a \(multiploDe10)\n ")

/*
var sum: Int = 0

@MainActor
func sumMultiplesOfThreeOrFive(ofLimit limit: Int) -> Int {
    
    for number in 1..<limit {
        if number % 3 == 0 || number % 5 == 0 {
            sum += number
        }
    }
    
    return sum
}

let multipleTen = sumMultiplesOfThreeOrFive(ofLimit: 10)
print("A soma total dos n√∫meros m√∫ltiplos de 5 ou 3, abaixo de 1000 √© igual a \(multipleTen)\n ")

var number: Int = 0
for numCode in 1..<10 {
     
    if (numCode % 3 == 0) || (numCode % 5 == 0){
        
        number += numCode
        //print(numCode)
    }
}
print("A soma total dos n√∫meros abaixo de 10 √© igual a \(number).")

number = 0
for numMil in 1..<1000 {
    
    if (numMil % 3 == 0) || (numMil % 5 == 0){
       
        number += numMil
        //print(numMil)
    }
}
print("A soma total dos n√∫meros abaixo de 1000 √© igua a \(number).")

func sumMultiples(ofLimit limit: Int) -> Int {
    
   var sum: Int = 0
    
    for number in 1..<limit {
        if number % 3 == 0 || number % 5 == 0 {
            sum += number
        }
    }
    
    return sum
}

let result1 = sumMultiples(ofLimit: 10)
print("A fun√ß√£o soma total dos n√∫meros abaixo de 10 √© igual a \(result1).")
let result2 = sumMultiples(ofLimit: 1000)
print("A fun√ß√£o soma total dos n√∫meros abaixo de 1000 √© igual a \(result2).")
let result3 = sumMultiples(ofLimit: 3000)
print("A fun√ß√£o soma total dos n√∫meros abaixo de 3000 √© igual a \(result3).")

/ *
print(" problema 2 - Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1,2,3,5,8,13,21,34,55,89,... By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.")

func fibonacci(ofLimit limit: Int) -> Int {
    var number1: Int = 1
    var number2: Int = 2
    var sum: Int = 0
    
    while number2 <= limit {
        
        if number2 % 2 == 0 {
            sum += number2
        }
        let temp = number1 + number2
        number1 = number2
        number2 = temp
    }
    return sum
}

print("A soma total dos n√∫meros pares da sequ√™ncia de Fibonacci at√© 4.000.000 √© igual a \(fibonacci(ofLimit: 4_000_000)).")

// Fun√ß√£o para gerar e imprimir a sequ√™ncia de Fibonacci at√© um limite
 
func generateFibonacci(upTo limit: Int) -> [Int] {
    var number1 = 1
    var number2 = 2
    var fibonacciSequence: [Int] = [number1, number2]

    while true {
        let nextNumber = number1 + number2
        if nextNumber > limit {
            break
        }
        fibonacciSequence.append(nextNumber)
        number1 = number2
        number2 = nextNumber
    }

    // Imprimir a sequ√™ncia completa
    print("Sequ√™ncia de Fibonacci at√© \(limit):")
    for number in fibonacciSequence {
        if number % 2 == 0 {
            print("\(number) (par)")
        } else {
            print(number)
        }
    }

    return fibonacciSequence
}
let evenSumOdd = generateFibonacci(upTo: 10)
print("Sequ√™ncia de Fibonacci at√© 10, √© igual a \(evenSumOdd).")

// Fun√ß√£o para somar apenas os n√∫meros pares da sequ√™ncia
func sumEvenFibonacciNumbersPair(from sequence: [Int]) -> Int {
    let evenNumbers = sequence.filter { $0 % 2 == 0 }
    return evenNumbers.reduce(0, +)
}

// Fun√ß√£o para somar apenas os n√∫meros √≠mpares da sequ√™ncia
func sumEvenFibonacciNumbersOdd(from sequence: [Int]) -> Int {
    let evenNumbers = sequence.filter { $0 % 2 != 0 }
    return evenNumbers.reduce(0, +)
}


// Uso
let fibonacciSeq = generateFibonacci(upTo: 4_000_000)
let evenSumPair = sumEvenFibonacciNumbersPair(from: fibonacciSeq)
print("A soma total dos n√∫meros pares da sequ√™ncia de Fibonacci at√© 4_000_000 √© igual a \(evenSumPair).")

let evenSum = sumEvenFibonacciNumbersOdd(from: fibonacciSeq)
print("A soma total dos n√∫meros √≠mpares da sequ√™ncia de Fibonacci at√© 4_000_000 √© igual a \(evenSum).")
print("--------3---------")
print("--- 3 problema - Os fatores primos de 13195 s√£o 5, 7, 13, 29. Qual √© o maior fator primo do n√∫mero 600851475143 ? ---")
          
func isPrime(ofNumber number: Int) -> Bool {
    if number <= 1 { return false }
    if number == 2 { return true }
    
    //sqrt()√© uma fun√ß√£o da biblioteca padr√£o: -> "square root" ‚Üí raiz quadrada.
    //(sqrt (Double (number))) ->  converte Int para Double
    for i in 2...Int(sqrt (Double (number))) {
        if number % i == 0 {
            return false
        } else {
        }
    }
    return true
}

let isNumberPrimo1 = isPrime(ofNumber: 600851475143)
print(" O n√∫mero 600851475143 √© primo ? \(isNumberPrimo1)")
let isNumberPrimo2 = isPrime(ofNumber: 600851475143)
print(" O n√∫mero 600851475143 √© primo ? \(isNumberPrimo2)")
let isNumberPrimo3 = isPrime(ofNumber: 7)
print(" O n√∫mero 7 √© primo ? \(isNumberPrimo3)")

func isNumPrime(ofNumber number: Int) -> Bool {
    if number <= 1 { return false }
    if number == 2 {
        print("\(number) - √â primo.")
        return true
    }

    for i in 2...Int(sqrt(Double(number))) {
        if number % i == 0 {
            print("\(number) - N√£o √© primo (divis√≠vel por \(i)).")
            return false
        }
    }

    print("\(number) - √â primo.")
    return true
}

let isNumberPrimo5 = isNumPrime(ofNumber: 600851475143)
print("O n√∫mero 600851475143 √© primo? \(isNumberPrimo5)")

let isNumberPrimo6 = isNumPrime(ofNumber: 600851475143)
print("O n√∫mero 600851475143 √© primo? \(isNumberPrimo6)")

let isNumberPrimo7 = isNumPrime(ofNumber: 7)
print("O n√∫mero 7 √© primo? \(isNumberPrimo7)")

/*
 Crivo de Erat√≥stenes
 L√≥gica:
 
 1- Comece com uma lista de n√∫meros de 2 at√© um limite.

 2- Elimine os m√∫ltiplos de 2 (exceto o pr√≥prio 2).

 3- V√° para o pr√≥ximo n√∫mero n√£o exclu√≠do e elimine seus m√∫ltiplos.

 4- Continue at√© o final.

 5- Os que sobrarem s√£o primos.
 */

func sieveOfEratosthenes(limit: Int) -> [Int] {
    var isPrime = [Bool](repeating: true, count: limit + 1)
    isPrime[0] = false
    isPrime[1] = false

    for i in 2...Int(sqrt(Double(limit))) {
        if isPrime[i] {
            for multiple in stride(from: i * i, through: limit, by: i) {
                isPrime[multiple] = false
            }
        }
    }

    return (2...limit).filter { isPrime[$0] }
}

let primesUpTo100 = sieveOfEratosthenes(limit: 100)
print(primesUpTo100)

func generatePrimes(ofLimit limit: Int) -> [Int] {
    var primes: [Int] = []

    for number in 2...limit {
        var isPrime = true
        
        if number > 3 {
            // Testa divisores de 2 at√© number / 2
            for divisor in 2...(number / 2) {
                if number % divisor == 0 {
                    isPrime = false
                    break
                }
            }
        }

        if isPrime {
            primes.append(number)
        }
    }

    return primes
}

let primesUpTo = generatePrimes(ofLimit: 50)
print("Primos at√© 50:", primesUpTo)

// fun√ß√£o para fatorar com num primos:
func primeFactors(of number: Int) -> [Int] {
    var n = number
    var factors: [Int] = []
    var divisor = 2

    while n > 1 {
        if n % divisor == 0 {
            factors.append(divisor)
            n /= divisor
        } else {
            divisor += 1
        }
    }

    return factors
}

let fatores = primeFactors(of: 13195)
print("Fatores primos de 13195 s√£o:", fatores)

let respostaProblema3 = primeFactors(of: 600851475143)
print("A resposta do Problema 3 -> Os fatores primos de 600851475143 s√£o:", respostaProblema3)

 
 /*
  problema 4
  Um n√∫mero pal√≠ndromo √© lido da mesma forma em ambas as dire√ß√µes. O maior pal√≠ndromo formado pelo produto de dois
  n√∫meros de -d√≠gitos s√£o
  .

  Encontre o maior pal√≠ndromo feito do produto de dois
  n√∫meros de -d√≠gitos.
  */

func isPalindrome(_ number: Int) -> Bool {
    let str = String(number)
    return str == String(str.reversed())
}

func largestPalindromeProduct(digits: Int) -> (palindrome: Int, factor1: Int, factor2: Int)? {
    let max = Int(pow(100.0, Double(digits))) - 1
    let min = Int(pow(100.0, Double(digits - 1)))
    
    var maxPalindrome = 0
    var result = (0, 0, 0)
    
    for i in stride(from: max, through: min, by: -1) {
        
        if i * i < maxPalindrome {
            break
        }
        
        for j in stride(from: i, through: min, by: -1) {
            let product = i * j
            
            if product < maxPalindrome {
                break
            }
            
            if isPalindrome(product) {
                maxPalindrome = product
                result = (product, i, j)
            }
        }
    }
    return result.0 > 0 ? result : nil
}

if let result = largestPalindromeProduct(digits: 2) {
    print("Maior pal√≠ndromo (2 d√≠gitos): \(result.palindrome) = \(result.factor1) √ó \(result.factor2)")
}

if let result = largestPalindromeProduct(digits: 3) {
    print("Maior pal√≠ndromo (3 d√≠gitos): \(result.palindrome) = \(result.factor1) √ó \(result.factor2)")
}


func isDivisibleByAll(_ n: Int, upTo max: Int) -> Bool {
    for i in 1...max {
        if n % 1 != 0 {
            return false
        }
    }
    return true
}

func smallestMultiple(upTo max: Int) -> Int {
    var n = max
    
    while true {
        if isDivisibleByAll(n, upTo: max) {
            return n
        }
        n += 1
    }
}

let result = smallestMultiple(upTo: 100)
print("O menor m√∫ltiplo comum de 1 at√© 10 √©: \(result)")


/*
 problema 5
 2520 √© o menor n√∫mero que pode ser dividido por cada um dos n√∫meros de 1 at√© 10 com resto igual a 0.

 Qual √© o menor n√∫mero positivo que √© igualmente divis√≠vel por todos os n√∫meros de 1 at√© 20 ?
 */
func greatestCommonDivisor(_ number1: Int, _ number2: Int) -> Int { //MDC
    var number1 = number1
    var number2 = number2
    while number2 != 0 {
        let temp = number2
        number2 = number1 % number2
        number1 = temp
    }
    return number1
}

func leastCommonMultiple(_ number1: Int, _ number2: Int) -> Int { //MMC
    return (number1 * number2) / greatestCommonDivisor(number1, number2)
}

func smallestMultiple(upTo max: Int) -> Int {
    var result = 1
    for i in 2...max {
        result = leastCommonMultiple(result, i)
    }
    return result
}

let resultado = smallestMultiple(upTo: 10)
print("üî¢ Menor m√∫ltiplo comum de 1 a 10 √©: \(resultado)") // ‚Üí 2520

let resultado2 = smallestMultiple(upTo: 20)
print("üî¢ Menor m√∫ltiplo comum de 1 a 20 √©: \(resultado2)") //232792560

extension Int {
    
    func mdc(com outro: Int) -> Int {
        var a = self
        var b = outro
        while b != 0 {
            (a, b) = (b, a % b)
        }
        return a
    }
    
    func mmc(com outro: Int) -> Int {
        return (self * outro) / self.mdc(com: outro)
    }
}

func smallestMultiple2(upTo max: Int) -> Int {
    var result = 1
    for i in 2...max {
        result = result.mmc(com: i)
    }
    return result
}

let menorMultiplo10 = smallestMultiple(upTo: 10)
print("üî¢ Menor m√∫ltiplo comum de 1 a 10 √©: \(menorMultiplo10)") // ‚Üí 2520

let menorMultiplo20 = smallestMultiple(upTo: 20)
print("üî¢ Menor m√∫ltiplo comum de 1 a 20 √©: \(menorMultiplo20)") //232792560
 
 
 extension Int {
     func maiorDivisorComum(com outro: Int) -> Int {
         var a = self
         var b = outro
         while b != 0 {
             (a, b) = (b, a % b)
         }
         return a
     }

     func menorMultiploComum(com outro: Int) -> Int {
         return (self * outro) / self.maiorDivisorComum(com: outro)
     }
 }

 func menorMultiploComum(ate numero: Int) -> Int {
     var resultado = 1
     for i in 2...numero {
         resultado = resultado.menorMultiploComum(com: i)
     }
     return resultado
 }

 // Uso:
 let resultado3 = menorMultiploComum(ate: 10)
 print("Menor m√∫ltiplo comum de 1 at√© 10 √©: \(resultado3)") // 2.520

let resultado4 = menorMultiploComum(ate: 20)
print("Menor m√∫ltiplo comum de 1 at√© 20 √©: \(resultado4)") // 232.792.560

 */
 

